// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Execute a Bless Function
	// (POST /api/v1/functions/execute)
	ExecuteFunction(ctx echo.Context) error
	// Install a Bless Function
	// (POST /api/v1/functions/install)
	InstallFunction(ctx echo.Context) error
	// Get the result of an Execution Request
	// (POST /api/v1/functions/requests/result)
	ExecutionResult(ctx echo.Context) error
	// Check Node health
	// (GET /api/v1/health)
	Health(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ExecuteFunction converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteFunction(ctx)
	return err
}

// InstallFunction converts echo context to params.
func (w *ServerInterfaceWrapper) InstallFunction(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstallFunction(ctx)
	return err
}

// ExecutionResult converts echo context to params.
func (w *ServerInterfaceWrapper) ExecutionResult(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecutionResult(ctx)
	return err
}

// Health converts echo context to params.
func (w *ServerInterfaceWrapper) Health(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Health(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/v1/functions/execute", wrapper.ExecuteFunction)
	router.POST(baseURL+"/api/v1/functions/install", wrapper.InstallFunction)
	router.POST(baseURL+"/api/v1/functions/requests/result", wrapper.ExecutionResult)
	router.GET(baseURL+"/api/v1/health", wrapper.Health)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
